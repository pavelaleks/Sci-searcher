<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sci-Searcher | Поисковик научной литературы</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            /* Light theme colors */
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --accent-primary: #3498db;
            --accent-secondary: #e74c3c;
            --success: #2ecc71;
            --warning: #f39c12;
            --border-color: #e1e5e9;
            --shadow: 0 4px 12px rgba(0,0,0,0.15);
            --shadow-hover: 0 8px 25px rgba(0,0,0,0.2);
        }
        
        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            --bg-secondary: #2c3e50;
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --accent-primary: #3498db;
            --accent-secondary: #e74c3c;
            --success: #27ae60;
            --warning: #f39c12;
            --border-color: #34495e;
            --shadow: 0 4px 12px rgba(0,0,0,0.3);
            --shadow-hover: 0 8px 25px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding: 20px;
            position: relative;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            letter-spacing: -0.02em;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            margin: 0;
            font-weight: 400;
        }

        .version-info {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
            margin-top: 8px;
            opacity: 0.7;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .developer-info {
            margin: 20px 0;
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .developer-info p {
            margin: 6px 0;
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .developer-info a {
            color: #fff;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .developer-info a:hover {
            color: #f0f0f0;
            text-decoration: underline;
        }

        .app-description {
            margin: 20px 0;
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .app-description p {
            margin: 0;
            font-size: 0.9rem;
            opacity: 0.9;
            line-height: 1.5;
            font-weight: 400;
        }

        .search-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
        }

        .main-search-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 20px;
        }

        .search-input-group {
            display: flex;
            gap: 12px;
            align-items: end;
        }

        .search-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
            transform: translateY(-1px);
        }

        .search-btn-main {
            background: linear-gradient(135deg, var(--accent-primary) 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Inter', sans-serif;
            min-width: 160px;
        }

        .search-btn-main:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .quick-filters {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .quick-filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .quick-filter-group label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .quick-filter-group select {
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.9rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            min-width: 120px;
        }

        .advanced-search-toggle {
            background: transparent;
            border: 2px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        .advanced-search-toggle:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .advanced-search-panel {
            display: none;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 16px;
        }

        .advanced-search-panel.active {
            display: block;
        }

        .advanced-filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .search-panel:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-2px);
        }

        .search-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            align-items: start;
            max-width: 100%;
        }

        .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            align-items: stretch;
            max-width: 100%;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            height: 72px;
        }

        .form-group label {
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            height: 24px;
            display: flex;
            align-items: center;
            line-height: 1.2;
            flex-shrink: 0;
        }

        .form-group input, .form-group select {
            padding: 10px 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            height: 42px;
            box-sizing: border-box;
            flex-shrink: 0;
            margin-top: auto;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
            transform: translateY(-1px);
        }

        .form-group small {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 3px;
            line-height: 1.3;
        }

        .search-btn {
            background: linear-gradient(135deg, var(--accent-primary) 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Inter', sans-serif;
            position: relative;
            overflow: hidden;
            width: 100%;
            margin-top: 8px;
        }

        .search-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .search-btn:hover::before {
            left: 100%;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .search-btn:active {
            transform: translateY(0);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            height: fit-content;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .results-count {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
        }

        .export-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .export-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .copy-btn {
            background: #17a2b8;
        }

        .copy-btn:hover {
            background: #138496;
        }

        .results-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .result-item {
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
            background: #fafbfc;
        }

        .result-item:hover {
            border-color: #667eea;
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .result-title {
            font-size: 1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .result-authors {
            color: #666;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .result-journal {
            color: #8e44ad;
            font-weight: 500;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }

        .result-year {
            color: #e74c3c;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }

        .result-abstract {
            color: #555;
            line-height: 1.4;
            font-size: 0.8rem;
            margin-bottom: 6px;
        }

        /* Стили для HTML-элементов в аннотациях */
        .result-abstract p {
            margin: 0 0 8px 0;
        }

        .result-abstract p:last-child {
            margin-bottom: 0;
        }

        .result-abstract em,
        .result-abstract i {
            font-style: italic;
        }

        .result-abstract strong,
        .result-abstract b {
            font-weight: bold;
        }

        .result-abstract span {
            display: inline;
        }

        .result-abstract div {
            display: block;
        }

        .result-abstract br {
            line-height: 1.2;
        }

        .abstract-preview {
            max-height: 60px;
            overflow: hidden;
            position: relative;
        }

        .abstract-preview::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(transparent, #fafbfc);
        }

        .abstract-full {
            max-height: none;
        }

        .toggle-abstract {
            background: none;
            border: none;
            color: #667eea;
            font-size: 0.75rem;
            cursor: pointer;
            padding: 2px 0;
            margin-top: 4px;
            text-decoration: underline;
        }

        .toggle-abstract:hover {
            color: #5a6fd8;
        }

        .result-checkbox {
            margin-right: 8px;
            transform: scale(0.9);
        }

        .result-item.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .selection-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            align-items: center;
            flex-wrap: wrap;
        }

        .select-all-btn, .clear-selection-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .select-all-btn:hover, .clear-selection-btn:hover {
            background: #5a6268;
        }

        .selected-count {
            font-size: 0.8rem;
            color: #666;
            font-weight: 500;
        }

        .selection-controls .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .selection-controls .export-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .result-doi {
            color: #3498db;
            font-size: 0.75rem;
            text-decoration: none;
        }

        .result-doi:hover {
            text-decoration: underline;
        }

        .result-link {
            color: #3498db;
            font-size: 0.85rem;
            text-decoration: none;
            display: inline-block;
            margin-top: 8px;
            padding: 5px 10px;
            background: #e3f2fd;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .result-link:hover {
            background: #bbdefb;
            text-decoration: none;
            transform: translateY(-1px);
        }

        .footer {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 15px 20px;
            margin-top: 20px;
            border-radius: 8px 8px 0 0;
        }

        .footer-content p {
            margin: 0;
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
        }

        @media (max-width: 1200px) {
            .container {
                padding: 15px;
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 15px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .search-input-group {
                flex-direction: column;
                gap: 12px;
            }
            
            .search-input {
                font-size: 1rem;
                padding: 14px 16px;
            }
            
            .search-btn-main {
                width: 100%;
                padding: 14px 20px;
                font-size: 1rem;
            }
            
            .quick-filters {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .quick-filter-group select {
                width: 100%;
            }
            
            .advanced-filters-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .results-panel {
                padding: 15px;
            }
            
            .result-item {
                padding: 12px;
            }
            
            .result-title {
                font-size: 1rem;
            }
            
            .result-authors {
                font-size: 0.8rem;
            }
            
            .result-journal {
                font-size: 0.8rem;
            }
            
            .export-buttons {
                flex-direction: column;
                gap: 8px;
            }
            
            .export-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .selection-controls {
                flex-direction: column;
                gap: 8px;
            }
            
            .select-all-btn, .clear-selection-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .analytics-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .footer {
                padding: 10px 15px;
                margin-top: 15px;
            }
            
            .footer-content p {
                font-size: 0.8rem;
            }
        }

        .hidden {
            display: none;
        }

        .analytics-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .analytics-panel h3 {
            color: var(--text-primary);
            margin-bottom: 16px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .analytics-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.3s ease;
        }

        .analytics-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .analytics-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .analytics-content {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .analytics-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .analytics-item:last-child {
            border-bottom: none;
        }

        .analytics-bar {
            width: 100%;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .analytics-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--success));
            transition: width 0.3s ease;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 5px;
            backdrop-filter: blur(10px);
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
        }

        .tab-btn.active {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .search-type {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .search-type label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 500;
        }

        .search-type input[type="radio"] {
            margin: 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .current-year-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .current-year-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .current-year-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .quick-periods {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .period-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .period-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .period-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }

        .period-btn.active {
            background: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }




        .results-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            display: none;
            margin-top: 20px;
        }

        .results-panel.active {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .export-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .export-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .copy-btn {
            background: #17a2b8;
        }

        .copy-btn:hover {
            background: #138496;
        }

        .results-list {
            max-height: 70vh;
            overflow-y: auto;
        }

        .result-item {
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .result-item:hover {
            border-color: #667eea;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .result-authors {
            color: #666;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .result-journal {
            color: #8e44ad;
            font-weight: 500;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .result-year {
            color: #e74c3c;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .result-abstract {
            color: #555;
            line-height: 1.5;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .result-doi {
            color: #3498db;
            font-size: 0.8rem;
            text-decoration: none;
        }

        .result-doi:hover {
            text-decoration: underline;
        }

        .result-link {
            color: #3498db;
            font-size: 0.8rem;
            text-decoration: none;
            display: inline-block;
            margin-top: 6px;
            padding: 4px 8px;
            background: #e3f2fd;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .result-link:hover {
            background: #bbdefb;
            text-decoration: none;
            transform: translateY(-1px);
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-toggle" id="themeToggle" title="Переключить тему">
                <svg viewBox="0 0 24 24">
                    <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/>
                </svg>
            </button>
            <h1>Sci-Searcher</h1>
            <p>Автономный поисковик научной литературы</p>
        </div>

        <!-- Основная поисковая панель -->
        <div class="search-panel">
            <form class="search-form" id="openalexForm">
                <div class="main-search-section">
                    <div class="search-input-group">
                        <input type="text" id="keywords" class="search-input" placeholder="Введите ключевые слова для поиска..." required>
                        <button type="submit" class="search-btn-main" id="openalexSearchBtn">
                            🔍 Поиск
                        </button>
                    </div>
                    
                    <div class="quick-filters">
                        <div class="quick-filter-group">
                            <label for="searchMode">Режим</label>
                            <select id="searchMode">
                                <option value="simple">Простой</option>
                                <option value="advanced">Расширенный</option>
                                <option value="exact">Точная фраза</option>
                            </select>
                        </div>
                        
                        <div class="quick-filter-group">
                            <label for="resultsLimit">Результатов</label>
                            <select id="resultsLimit">
                                <option value="50">50</option>
                                <option value="100">100</option>
                                <option value="200">200</option>
                                <option value="300">300</option>
                                <option value="500">500</option>
                            </select>
                        </div>
                        
                        <div class="quick-filter-group">
                            <label for="startYear">Год от</label>
                            <input type="number" id="startYear" min="1700" placeholder="2019" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 0.9rem; background: var(--bg-secondary); color: var(--text-primary); font-family: 'Inter', sans-serif; min-width: 120px;">
                        </div>
                        
                        <div class="quick-filter-group">
                            <label for="endYear">Год до</label>
                            <input type="number" id="endYear" min="1700" placeholder="2025" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 8px; font-size: 0.9rem; background: var(--bg-secondary); color: var(--text-primary); font-family: 'Inter', sans-serif; min-width: 120px;">
                        </div>
                        
                        <div class="year-range-info" style="font-size: 0.8rem; color: #666; margin-top: 5px; text-align: center;">
                            📅 По умолчанию: последние 6 лет | Диапазон: от 1700 года до <span id="currentYearDisplay">2025</span> года и далее
                        </div>
                        
                        <button type="button" class="advanced-search-toggle" id="advancedToggle">
                            ⚙️ Расширенные фильтры
                        </button>
                    </div>
                </div>
                
                <div class="advanced-search-panel" id="advancedPanel">
                    <div class="advanced-filters-grid">
                        <div class="form-group">
                            <label for="filterType">Тип публикаций</label>
                            <select id="filterType">
                                <option value="all">Все публикации</option>
                                <option value="journals">Только журнальные статьи</option>
                                <option value="conferences">Конференции</option>
                                <option value="books">Книги и главы</option>
                                <option value="no_repositories">Исключить репозитории</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="language">Язык публикации</label>
                            <select id="language">
                                <option value="all">Все языки</option>
                                <option value="ru">Русский</option>
                                <option value="kk">Казахский</option>
                                <option value="en">Английский</option>
                                <option value="de">Немецкий</option>
                                <option value="fr">Французский</option>
                                <option value="es">Испанский</option>
                                <option value="zh-cn">Китайский (упрощенный)</option>
                                <option value="zh-tw">Китайский (традиционный)</option>
                                <option value="ja">Японский</option>
                                <option value="ko">Корейский</option>
                                <option value="ar">Арабский</option>
                                <option value="pt">Португальский</option>
                                <option value="it">Итальянский</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="openAccess">Открытый доступ</label>
                            <select id="openAccess">
                                <option value="all">Все публикации</option>
                                <option value="open">Только открытый доступ</option>
                                <option value="closed">Только платные</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="sortOrder">Сортировка</label>
                            <select id="sortOrder">
                                <option value="newest">Сначала новые</option>
                                <option value="oldest">Сначала старые</option>
                                <option value="relevance">По релевантности</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>&nbsp;</label>
                            <button type="button" onclick="window.sciSearcher.testAllFilterCombinations()" 
                                    style="background: #17a2b8; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; width: 100%;">
                                🧪 Тестировать все фильтры
                            </button>
                        </div>
                    </div>
                </div>
            </form>
        </div>

        <div class="results-panel" id="resultsPanel">
            <div class="results-header">
                <div class="results-count" id="resultsCount"></div>
                <div class="export-buttons">
                    <button class="export-btn" id="downloadApaBtn">
                        📄 APA
                    </button>
                    <button class="export-btn" id="downloadGostBtn">
                        📋 ГОСТ
                    </button>
                    <button class="export-btn" id="downloadBibtexBtn">
                        📚 BibTeX
                    </button>
                    <button class="export-btn copy-btn" id="copyBtn">
                        📋 Копировать
                    </button>
                </div>
            </div>
            
            <div class="analytics-panel" id="analyticsPanel" style="display: none;">
                <h3>📊 Аналитика результатов</h3>
                <div class="analytics-grid">
                    <div class="analytics-card">
                        <div class="analytics-title">Топ авторы</div>
                        <div class="analytics-content" id="topAuthors"></div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-title">Топ журналы</div>
                        <div class="analytics-content" id="topJournals"></div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-title">Распределение по годам</div>
                        <div class="analytics-content" id="yearDistribution"></div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-title">Открытый доступ</div>
                        <div class="analytics-content" id="openAccessStats"></div>
                    </div>
                </div>
            </div>
            <div class="selection-controls" id="selectionControls" style="display: none;">
                <input type="checkbox" id="selectAllCheckbox">
                <label for="selectAllCheckbox">Выбрать все</label>
                <button class="select-all-btn" id="selectAllBtn">Выбрать все</button>
                <button class="clear-selection-btn" id="clearSelectionBtn">Очистить</button>
                <span class="selected-count" id="selectedCount">Выбрано: 0</span>
                <button class="export-btn" id="downloadSelectedApaBtn" style="display: none;">📄 APA</button>
                <button class="export-btn" id="downloadSelectedGostBtn" style="display: none;">📋 ГОСТ</button>
                <button class="export-btn" id="downloadSelectedTxtBtn" style="display: none;">📥 TXT</button>
            </div>
            <div class="results-list" id="resultsList"></div>
        </div>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 Разработка П.В. Алексеев, Горно-Алтайский государственный университет</p>
            <p class="version-info" id="versionInfo">v1.0.0</p>
        </div>
    </footer>

    <script>
        /**
         * Модуль фильтрации результатов для Sci-Searcher
         * Обеспечивает строгую фильтрацию по всем параметрам
         */
        class FilterEngine {
            /**
             * Нормализует значения годов (преобразует пустые строки в null)
             */
            static normalizeYear(year) {
                if (!year || year === '' || year === 'undefined' || year === 'null') {
                    return null;
                }
                const yearNum = parseInt(year);
                return isNaN(yearNum) ? null : yearNum;
            }

            /**
             * Применяет фильтр по годам публикации - СТРОГАЯ фильтрация
             */
            static filterByYear(results, startYear, endYear) {
                const start = this.normalizeYear(startYear);
                const end = this.normalizeYear(endYear);
                
                // Если оба года не указаны, возвращаем все результаты
                if (start === null && end === null) {
                    return results;
                }
                
                console.log(`🔍 СТРОГАЯ фильтрация по годам: ${start || 'не указан'} - ${end || 'не указан'}`);
                
                const originalCount = results.length;
                const filtered = results.filter(work => {
                    const year = work.publication_year;
                    
                    // Если год не указан в работе, ИСКЛЮЧАЕМ её из результатов
                    if (!year || year === null || year === undefined) {
                        return false;
                    }
                    
                    const workYear = parseInt(year);
                    if (isNaN(workYear)) {
                        return false;
                    }
                    
                    // Строгая проверка диапазона
                    if (start !== null && end !== null) {
                        return workYear >= start && workYear <= end;
                    } else if (start !== null) {
                        return workYear >= start;
                    } else if (end !== null) {
                        return workYear <= end;
                    }
                    
                    return true;
                });
                
                console.log(`✅ Фильтрация по годам: ${originalCount} → ${filtered.length} результатов`);
                
                if (originalCount > filtered.length) {
                    console.log(`⚠️ Отфильтровано ${originalCount - filtered.length} результатов вне диапазона годов`);
                }
                
                return filtered;
            }

            /**
             * Применяет фильтр по языку
             */
            static filterByLanguage(results, language) {
                if (!language || language === 'all') {
                    return results;
                }
                
                const originalCount = results.length;
                const filtered = results.filter(work => {
                    const workLanguage = work.language;
                    if (!workLanguage) {
                        return false;
                    }
                    return workLanguage === language;
                });
                
                console.log(`🔍 Фильтрация по языку "${language}": ${originalCount} → ${filtered.length} результатов`);
                return filtered;
            }

            /**
             * Применяет фильтр по типу публикации
             */
            static filterByType(results, filterType) {
                if (!filterType || filterType === 'all') {
                    return results;
                }
                
                const typeMap = {
                    'journals': ['journal-article'],
                    'conferences': ['proceedings-article'],
                    'books': ['book', 'monograph'],
                    'no_repositories': ['journal-article', 'proceedings-article', 'book', 'monograph']
                };
                
                const allowedTypes = typeMap[filterType];
                if (!allowedTypes) {
                    return results;
                }
                
                const originalCount = results.length;
                const filtered = results.filter(work => {
                    const workType = work.type;
                    return workType && allowedTypes.includes(workType);
                });
                
                console.log(`🔍 Фильтрация по типу "${filterType}": ${originalCount} → ${filtered.length} результатов`);
                return filtered;
            }

            /**
             * Применяет фильтр по открытому доступу
             */
            static filterByOpenAccess(results, openAccess) {
                if (!openAccess || openAccess === 'all') {
                    return results;
                }
                
                const originalCount = results.length;
                const filtered = results.filter(work => {
                    const isOa = work.is_oa === true;
                    if (openAccess === 'open') {
                        return isOa;
                    } else if (openAccess === 'closed') {
                        return !isOa;
                    }
                    return true;
                });
                
                console.log(`🔍 Фильтрация по доступу "${openAccess}": ${originalCount} → ${filtered.length} результатов`);
                return filtered;
            }

            /**
             * Применяет сортировку
             */
            static applySorting(results, sortOrder) {
                if (!sortOrder || sortOrder === 'relevance') {
                    return results;
                }
                
                const sorted = [...results];
                
                if (sortOrder === 'newest') {
                    sorted.sort((a, b) => {
                        const yearA = parseInt(a.publication_year) || 0;
                        const yearB = parseInt(b.publication_year) || 0;
                        return yearB - yearA;
                    });
                } else if (sortOrder === 'oldest') {
                    sorted.sort((a, b) => {
                        const yearA = parseInt(a.publication_year) || 0;
                        const yearB = parseInt(b.publication_year) || 0;
                        return yearA - yearB;
                    });
                }
                
                return sorted;
            }

            /**
             * Применяет все фильтры к результатам
             */
            static applyAllFilters(results, filters) {
                let filtered = results;
                const originalCount = filtered.length;
                
                filtered = this.filterByYear(filtered, filters.startYear, filters.endYear);
                filtered = this.filterByLanguage(filtered, filters.language);
                filtered = this.filterByType(filtered, filters.filterType);
                filtered = this.filterByOpenAccess(filtered, filters.openAccess);
                filtered = this.applySorting(filtered, filters.sortOrder);
                
                console.log(`✅ Итоговая фильтрация: ${originalCount} → ${filtered.length} результатов`);
                return filtered;
            }
        }

        class SciSearcher {
        constructor() {
            console.log('🔧 Создание экземпляра SciSearcher...');
            this.results = [];
            this.currentSource = 'openalex';
            this.selectedResults = new Set();
            this.cache = new Map(); // Кэш для результатов поиска
            this.cacheExpiry = 5 * 60 * 1000; // 5 минут
            this.version = '1.0.0'; // Текущая версия
            this.updateVersionDisplay();
            this.init();
        }

        // Обновление отображения версии
        updateVersionDisplay() {
            const versionElement = document.getElementById('versionInfo');
            if (versionElement) {
                versionElement.textContent = `v${this.version}`;
            }
        }

        // Инициализация версии: берём последнюю версию из GitHub (меняется только при push)
        async initVersion() {
            try {
                const cacheKey = 'sci_searcher_commit';
                const cacheTimeKey = 'sci_searcher_commit_checked_at';
                const cacheTtlMs = 5 * 60 * 1000; // 5 минут для снижения нагрузки на API

                const now = Date.now();
                const lastChecked = parseInt(localStorage.getItem(cacheTimeKey) || '0', 10);
                const cached = localStorage.getItem(cacheKey);

                // Если недавно проверяли — используем кешированную версию
                if (cached && lastChecked && (now - lastChecked) < cacheTtlMs) {
                    this.version = cached;
                    this.updateVersionDisplay();
                    return;
                }

                // Запрашиваем последний коммит основной ветки
                const response = await fetch('https://api.github.com/repos/pavelaleks/Sci-searcher/commits/main', {
                    headers: { 'Accept': 'application/vnd.github+json' }
                });
                if (!response.ok) throw new Error('GitHub API error: ' + response.status);
                const data = await response.json();

                const sha = (data && data.sha) ? String(data.sha) : '';
                const shortSha = sha.substring(0, 7) || 'unknown';
                const commitDateIso = data?.commit?.committer?.date || '';
                const datePart = commitDateIso ? commitDateIso.slice(0, 10).replace(/-/g, '') : '';

                // Формат версии: 1.0.<YYYYMMDD>-<shortsha>
                const computedVersion = `1.0.${datePart}-${shortSha}`;

                this.version = computedVersion;
                this.updateVersionDisplay();

                // Кешируем
                localStorage.setItem(cacheKey, computedVersion);
                localStorage.setItem(cacheTimeKey, String(now));

                console.log(`Sci-Searcher версия по последнему коммиту: ${this.version}`);
            } catch (e) {
                // В случае ошибки оставляем последнюю известную версию
                console.warn('Не удалось получить версию из GitHub, используется локальная:', e?.message || e);
            }
        }

            init() {
                console.log('🚀 Инициализация SciSearcher...');
                this.initVersion(); // Версия меняется только при новом push в репозиторий
                this.initTheme();
                this.initForms();
                this.initExportButtons();
                this.initSelectionControls();
                this.checkApiStatus();
                console.log('✅ SciSearcher инициализирован успешно');
            }

            initTheme() {
                // Загружаем сохраненную тему
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                
                // Инициализируем переключатель темы
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        const currentTheme = document.documentElement.getAttribute('data-theme');
                        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                        document.documentElement.setAttribute('data-theme', newTheme);
                        localStorage.setItem('theme', newTheme);
                        
                        // Анимация переключения
                        themeToggle.style.transform = 'rotate(180deg)';
                        setTimeout(() => {
                            themeToggle.style.transform = 'rotate(0deg)';
                        }, 300);
                    });
                }
            }

            initForms() {
                const openalexForm = document.getElementById('openalexForm');
                if (!openalexForm) {
                    console.error('Форма openalexForm не найдена!');
                    return;
                }
                
                openalexForm.addEventListener('submit', (e) => this.handleOpenAlexSearch(e));
                console.log('Форма поиска инициализирована');
                
                // Инициализируем переключатель расширенных фильтров
                const advancedToggle = document.getElementById('advancedToggle');
                const advancedPanel = document.getElementById('advancedPanel');
                
                if (advancedToggle && advancedPanel) {
                    advancedToggle.addEventListener('click', () => {
                        const isActive = advancedPanel.classList.contains('active');
                        if (isActive) {
                            advancedPanel.classList.remove('active');
                            advancedToggle.textContent = '⚙️ Расширенные фильтры';
                        } else {
                            advancedPanel.classList.add('active');
                            advancedToggle.textContent = '⚙️ Скрыть фильтры';
                        }
                    });
                }
            }

            initExportButtons() {
                // Используем делегирование событий для динамически создаваемых кнопок
                document.addEventListener('click', (e) => {
                    if (e.target.id === 'downloadApaBtn') {
                        e.preventDefault();
                        this.downloadResults('apa');
                    } else if (e.target.id === 'downloadGostBtn') {
                        e.preventDefault();
                        this.downloadResults('gost');
                    } else if (e.target.id === 'downloadBibtexBtn') {
                        e.preventDefault();
                        this.downloadResults('bibtex');
                    } else if (e.target.id === 'copyBtn') {
                        e.preventDefault();
                        this.copyResults();
                    } else if (e.target.id === 'downloadSelectedApaBtn') {
                        e.preventDefault();
                        this.downloadSelectedResults('apa');
                    } else if (e.target.id === 'downloadSelectedGostBtn') {
                        e.preventDefault();
                        this.downloadSelectedResults('gost');
                    } else if (e.target.id === 'downloadSelectedTxtBtn') {
                        e.preventDefault();
                        this.downloadSelectedResults('txt');
                    }
                });
            }

            initSelectionControls() {
                const selectAllBtn = document.getElementById('selectAllBtn');
                const clearSelectionBtn = document.getElementById('clearSelectionBtn');
                const selectAllCheckbox = document.getElementById('selectAllCheckbox');

                if (selectAllBtn) selectAllBtn.addEventListener('click', () => this.selectAllResults());
                if (clearSelectionBtn) clearSelectionBtn.addEventListener('click', () => this.clearSelection());
                if (selectAllCheckbox) selectAllCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.selectAllResults();
                    } else {
                        this.clearSelection();
                    }
                });
            }

            async handleOpenAlexSearch(e) {
                e.preventDefault();
                console.log('🔍 Начинаем поиск...');
                
                const keywords = document.getElementById('keywords').value.trim();
                const searchModeElement = document.getElementById('searchMode');
                const searchMode = searchModeElement ? searchModeElement.value : 'simple';
                const startYearElement = document.getElementById('startYear');
                const endYearElement = document.getElementById('endYear');
                let startYear = startYearElement ? (startYearElement.value || '').trim() : '';
                let endYear = endYearElement ? (endYearElement.value || '').trim() : '';
                const resultsLimit = document.getElementById('resultsLimit').value;
                const sortOrder = document.getElementById('sortOrder').value;
                const filterType = document.getElementById('filterType').value;
                const language = document.getElementById('language').value;
                const openAccess = document.getElementById('openAccess').value;

                // Применяем значения по умолчанию для годов (последние 6 лет)
                const currentYear = new Date().getFullYear();
                const defaultStartYear = currentYear - 5; // 2020 для 2025 года
                const defaultEndYear = currentYear; // 2025

                if (!startYear || startYear === '') {
                    startYear = defaultStartYear.toString();
                    document.getElementById('startYear').value = startYear;
                    console.log(`📅 Применено значение по умолчанию для начального года: ${startYear}`);
                }
                
                if (!endYear || endYear === '') {
                    endYear = defaultEndYear.toString();
                    document.getElementById('endYear').value = endYear;
                    console.log(`📅 Применено значение по умолчанию для конечного года: ${endYear}`);
                }

                // Обрабатываем режим поиска
                let processedKeywords = keywords;
                if (searchMode === 'exact') {
                    // Точная фраза - заключаем в кавычки (если еще не заключено)
                    if (!keywords.startsWith('"') || !keywords.endsWith('"')) {
                        processedKeywords = `"${keywords}"`;
                    } else {
                        processedKeywords = keywords;
                    }
                    console.log(`🔍 Режим поиска: Точная фраза "${processedKeywords}"`);
                } else if (searchMode === 'advanced') {
                    // Расширенный режим - можно использовать операторы AND, OR, NOT
                    // OpenAlex поддерживает булевы операторы: AND, OR, NOT
                    // Примеры: "machine learning" AND "neural networks"
                    // Примеры: "python" OR "javascript"
                    // Примеры: "covid" NOT "vaccine"
                    processedKeywords = keywords;
                    console.log(`🔍 Режим поиска: Расширенный (можно использовать AND, OR, NOT)`);
                    console.log(`📝 Примеры использования:`);
                    console.log(`   - "machine learning" AND "neural networks"`);
                    console.log(`   - "python" OR "javascript"`);
                    console.log(`   - "covid" NOT "vaccine"`);
                } else {
                    // Простой режим - обычный поиск, OpenAlex автоматически ищет по всем словам
                    processedKeywords = keywords;
                    console.log(`🔍 Режим поиска: Простой (поиск по всем словам)`);
                }

                console.log('Параметры поиска:', { keywords: processedKeywords, searchMode, startYear, endYear, resultsLimit, sortOrder, filterType, language, openAccess });

                if (!keywords) {
                    alert('Пожалуйста, введите ключевые слова для поиска');
                    return;
                }

                this.showLoading();
                
                try {
                    console.log('Вызываем searchOpenAlex...');
                    const results = await this.searchOpenAlex(processedKeywords, startYear, endYear, resultsLimit, sortOrder, filterType, language, openAccess);
                    console.log('Получено результатов:', results.length);
                    this.displayResults(results);
                } catch (error) {
                    console.error('Ошибка при поиске:', error);
                    this.showError('Ошибка при поиске: ' + error.message);
                }
            }




            async searchOpenAlex(keywords, startYear, endYear, resultsLimit, sortOrder = 'newest', filterType = 'all', language = 'all', openAccess = 'all') {
                // Проверяем кэш
                const cacheKey = this.getCacheKey(keywords, startYear, endYear, resultsLimit, sortOrder, filterType, language, openAccess);
                const cachedResults = this.getFromCache(cacheKey);
                if (cachedResults) {
                    return cachedResults;
                }

                // Определяем количество результатов на странице с учетом ограничений API
                const perPage = 50; // Всегда используем 50 на страницу для стабильности
                const targetResults = parseInt(resultsLimit);
                
                // Валидация годов
                const currentYear = new Date().getFullYear();
                const minYear = 1700; // Минимальный год для поиска
                if (startYear && startYear < minYear) {
                    throw new Error(`Год начала должен быть не ранее ${minYear}`);
                }
                if (endYear && endYear < minYear) {
                    throw new Error(`Год окончания должен быть не ранее ${minYear}`);
                }
                if (startYear && endYear && startYear > endYear) {
                    throw new Error('Год начала не может быть больше года окончания');
                }
                
                // Создаем базовый URL с основными параметрами
                // ВАЖНО: Не используем select для authorships, чтобы получить полную структуру
                let baseUrl = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=${perPage}&data_version=2`;
                
                // Определяем приоритет фильтров (сначала самые надежные)
                const filters = [];
                
                // 1. Фильтр по типу публикаций (самый надежный)
                if (filterType === 'journals') {
                    filters.push('type:journal-article');
                } else if (filterType === 'conferences') {
                    filters.push('type:proceedings-article');
                } else if (filterType === 'books') {
                    filters.push('type:book,monograph');
                } else if (filterType === 'no_repositories') {
                    filters.push('type:journal-article,proceedings-article,book,monograph');
                }
                
                // 2. Фильтр по открытому доступу (довольно надежный)
                if (openAccess === 'open') {
                    filters.push('is_oa:true');
                } else if (openAccess === 'closed') {
                    filters.push('is_oa:false');
                }
                
                // 3. Фильтр по годам (может вызывать проблемы)
                if (startYear && endYear) {
                    filters.push(`publication_year:${startYear}-${endYear}`);
                } else if (startYear) {
                    filters.push(`publication_year:>=${startYear}`);
                } else if (endYear) {
                    filters.push(`publication_year:<=${endYear}`);
                }
                
                // 4. Фильтр по языку (может вызывать проблемы)
                if (language !== 'all') {
                    filters.push(`language:${language}`);
                }
                
                // Добавляем фильтры к URL
                if (filters.length > 0) {
                    baseUrl += `&filter=${filters.join(',')}`;
                }
                
                // Добавляем сортировку
                switch(sortOrder) {
                    case 'oldest':
                        baseUrl += '&sort=publication_date:asc';
                        break;
                    case 'relevance':
                        baseUrl += '&sort=relevance_score:desc';
                        break;
                    case 'newest':
                    default:
                        baseUrl += '&sort=publication_date:desc';
                        break;
                }
                
                let url = baseUrl;

                console.log('OpenAlex API URL:', url);
                console.log('Search parameters:', { keywords, startYear, endYear, resultsLimit });
                console.log('Year filters applied:', { startYear, endYear, hasFilters: !!(startYear || endYear) });
                console.log('Using OpenAlex data_version=2 (improved metadata quality)');

                try {
                    // Добавляем задержку перед первым запросом для предотвращения rate limiting
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                        }
                    });
                    
                    // Обработка ответа
                    if (response.ok) {
                        // Успешный ответ - обрабатываем данные
                        const data = await response.json();
                        console.log('OpenAlex API response:', data);
                        console.log('Total results found:', data.meta?.count || 0);
                        
                        let results = data.results || [];
                        
                        // Добавляем информационное сообщение о серверной фильтрации
                        if (results.length > 0) {
                            const appliedFilters = [];
                            if (filterType !== 'all') appliedFilters.push(`типу "${filterType}"`);
                            if (language !== 'all') appliedFilters.push(`языку "${language}"`);
                            if (openAccess !== 'all') appliedFilters.push(`доступу "${openAccess}"`);
                            if (startYear || endYear) appliedFilters.push(`годам ${startYear || 'не указан'}-${endYear || 'не указан'}`);
                            
                            if (appliedFilters.length > 0) {
                                results[0]._info = `✅ Серверная фильтрация применена по ${appliedFilters.join(', ')}. Найдено ${results.length} результатов.`;
                            }
                        }
                        
                        // Пагинация для получения большего количества результатов
                        if (targetResults > 50 && data.meta && data.meta.count > perPage) {
                            const totalCount = Math.min(data.meta.count, targetResults);
                            const totalPages = Math.ceil(totalCount / perPage);
                            const maxPages = Math.min(totalPages, 5);
                            
                            console.log(`Найдено ${totalCount} результатов, делаем ${maxPages} запросов`);
                            
                            const updateProgress = (page, total) => {
                                const resultsList = document.getElementById('resultsList');
                                if (resultsList) {
                                    const progress = Math.round((page / total) * 100);
                                    resultsList.innerHTML = `
                                        <div class="loading">
                                            <div class="spinner"></div>
                                            <div>Загрузка результатов... Страница ${page} из ${total}</div>
                                            <div style="margin-top: 10px; width: 200px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 10px auto;">
                                                <div style="width: ${progress}%; height: 20px; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;
                                }
                            };
                            
                            for (let page = 2; page <= maxPages; page++) {
                                try {
                                    updateProgress(page, maxPages);
                                    await new Promise(resolve => setTimeout(resolve, 600));
                                    
                                    const pageUrl = url + `&page=${page}`;
                                    console.log(`Запрос страницы ${page}:`, pageUrl);
                                    
                                    const pageResponse = await fetch(pageUrl);
                                    
                                    if (!pageResponse.ok) {
                                        console.warn(`Ошибка при запросе страницы ${page}:`, pageResponse.status);
                                    break;
                                    }
                                    
                                    const pageData = await pageResponse.json();
                                    results = results.concat(pageData.results || []);
                                    
                                    console.log(`Получено ${pageData.results?.length || 0} результатов со страницы ${page}. Всего: ${results.length}`);
                                    
                                } catch (error) {
                                    console.warn(`Ошибка при получении страницы ${page}:`, error.message);
                                    break;
                                }
                            }
                        }
                        
                        // КРИТИЧЕСКИ ВАЖНО: Применяем строгую фильтрацию на ВСЕХ результатах
                        // API может не всегда корректно применять фильтры, особенно по годам
                        if (Array.isArray(results) && results.length > 0) {
                            console.log(`🔍 Применяем строгую фильтрацию к ${results.length} результатам`);
                            try {
                                if (typeof FilterEngine !== 'undefined' && FilterEngine.applyAllFilters) {
                                    const filters = {
                                        startYear: startYear,
                                        endYear: endYear,
                                        language: language,
                                        filterType: filterType,
                                        openAccess: openAccess,
                                        sortOrder: sortOrder
                                    };
                                    results = FilterEngine.applyAllFilters(results, filters);
                                    console.log(`✅ Фильтрация применена, осталось ${results.length} результатов`);
                                } else {
                                    console.error('❌ FilterEngine не определен!');
                                }
                            } catch (filterError) {
                                console.error('❌ Ошибка при применении фильтров:', filterError);
                                // Продолжаем с неотфильтрованными результатами
                            }
                        }
                        
                        // Сохраняем результаты в кэш
                        this.setCache(cacheKey, results);
                        
                        return results;
                        
                    } else {
                        // Обработка ошибок
                        console.log(`Ошибка ${response.status} с полными фильтрами, пробуем поэтапный fallback...`);
                        
                        // Этап 1: Убираем проблемные фильтры (язык и годы)
                        let fallbackUrl = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=${perPage}&data_version=2`;
                        
                        // Добавляем только надежные фильтры
                        const safeFilters = [];
                            if (filterType === 'journals') {
                            safeFilters.push('type:journal-article');
                            } else if (filterType === 'conferences') {
                            safeFilters.push('type:proceedings-article');
                            } else if (filterType === 'books') {
                            safeFilters.push('type:book,monograph');
                            } else if (filterType === 'no_repositories') {
                            safeFilters.push('type:journal-article,proceedings-article,book,monograph');
                            }
                            
                            if (openAccess === 'open') {
                            safeFilters.push('is_oa:true');
                            } else if (openAccess === 'closed') {
                            safeFilters.push('is_oa:false');
                        }
                        
                        if (safeFilters.length > 0) {
                            fallbackUrl += `&filter=${safeFilters.join(',')}`;
                        }
                        
                        // Добавляем сортировку
                        switch(sortOrder) {
                            case 'oldest':
                                fallbackUrl += '&sort=publication_date:asc';
                                break;
                            case 'relevance':
                                fallbackUrl += '&sort=relevance_score:desc';
                                break;
                            case 'newest':
                            default:
                                fallbackUrl += '&sort=publication_date:desc';
                                break;
                        }
                        
                        console.log('Fallback URL (без проблемных фильтров):', fallbackUrl);
                            
                            const fallbackResponse = await fetch(fallbackUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                                }
                            });
                            
                            if (fallbackResponse.ok) {
                                const fallbackData = await fallbackResponse.json();
                                let results = fallbackData.results || [];
                                
                            console.log(`Fallback успешен, получено ${results.length} результатов`);
                            
                            // Применяем СТРОГУЮ фильтрацию через FilterEngine
                            const originalCount = results.length;
                            if (Array.isArray(results) && results.length > 0) {
                                try {
                                    if (typeof FilterEngine !== 'undefined' && FilterEngine.applyAllFilters) {
                                        const filters = {
                                            startYear: startYear,
                                            endYear: endYear,
                                            language: language,
                                            filterType: filterType,
                                            openAccess: openAccess,
                                            sortOrder: sortOrder
                                        };
                                        results = FilterEngine.applyAllFilters(results, filters);
                                        console.log(`✅ Фильтрация применена: ${originalCount} → ${results.length}`);
                                    }
                                } catch (filterError) {
                                    console.error('❌ Ошибка при применении фильтров:', filterError);
                                }
                            }
                            
                            // Добавляем информационное сообщение о клиентской фильтрации
                            if (results.length > 0 && (language !== 'all' || startYear || endYear)) {
                                const warnings = [];
                                if (language !== 'all') warnings.push(`языку "${language}"`);
                                if (startYear || endYear) warnings.push(`годам ${startYear || 'не указан'}-${endYear || 'не указан'}`);
                                
                                results[0]._info = `✅ Применена строгая клиентская фильтрация по ${warnings.join(' и ')}. Показано ${results.length} из ${originalCount} результатов.`;
                                }
                                
                                return results;
                            } else {
                            // Этап 2: Если и fallback не работает, пробуем минимальный запрос
                            console.warn(`Fallback также не работает (${fallbackResponse.status}), пробуем минимальный запрос...`);
                                
                            const minimalUrl = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=25&data_version=2`;
                                
                                try {
                                const minimalResponse = await fetch(minimalUrl, {
                                        method: 'GET',
                                        headers: {
                                            'Accept': 'application/json',
                                            'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                                        }
                                    });
                                    
                                if (minimalResponse.ok) {
                                    const minimalData = await minimalResponse.json();
                                    let results = minimalData.results || [];
                                    
                                    console.log(`Минимальный запрос успешен, получено ${results.length} результатов`);
                                    
                                    // Применяем СТРОГУЮ фильтрацию через FilterEngine
                                    const originalCount = results.length;
                                    if (Array.isArray(results) && results.length > 0) {
                                        try {
                                            if (typeof FilterEngine !== 'undefined' && FilterEngine.applyAllFilters) {
                                                const filters = {
                                                    startYear: startYear,
                                                    endYear: endYear,
                                                    language: language,
                                                    filterType: filterType,
                                                    openAccess: openAccess,
                                                    sortOrder: sortOrder
                                                };
                                                results = FilterEngine.applyAllFilters(results, filters);
                                                console.log(`✅ Фильтрация применена: ${originalCount} → ${results.length}`);
                                            }
                                        } catch (filterError) {
                                            console.error('❌ Ошибка при применении фильтров:', filterError);
                                        }
                                    }
                                    
                                    // Добавляем информационное сообщение
                                    if (results.length > 0) {
                                        results[0]._info = `✅ Применена полная строгая клиентская фильтрация. Показано ${results.length} результатов из ${originalCount}.`;
                                    }
                                    
                                    return results;
                                }
                            } catch (minimalError) {
                                console.warn('Минимальный запрос также не удался:', minimalError);
                                }
                                
                                // Если все методы не работают, показываем дружелюбное сообщение
                                throw new Error('OpenAlex API временно недоступен. Это может быть связано с:\n\n' +
                                    '• Временными ограничениями сервиса\n' +
                                    '• Высокой нагрузкой на сервер\n' +
                                    '• Техническими работами\n\n' +
                                    'Рекомендации:\n' +
                                    '• Попробуйте через несколько минут\n' +
                                    '• Упростите поисковый запрос\n' +
                                    '• Проверьте интернет-соединение');
                            }
                            
                            // Если fallback не сработал, проверяем конкретные статусы ошибок
                            if (response.status === 429) {
                                // Обработка ошибки 429 (превышен лимит запросов)
                            console.warn('Превышен лимит запросов (429), пробуем упрощенный запрос...');
                            
                                const limitedUrl = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=10&data_version=2`;
                            
                            try {
                                const limitedResponse = await fetch(limitedUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                                    }
                                });
                                
                                if (limitedResponse.ok) {
                                    const limitedData = await limitedResponse.json();
                                        let results = limitedData.results || [];
                                        
                                        // Применяем СТРОГУЮ фильтрацию через FilterEngine
                                        if (Array.isArray(results) && results.length > 0) {
                                            try {
                                                if (typeof FilterEngine !== 'undefined' && FilterEngine.applyAllFilters) {
                                                    const filters = {
                                                        startYear: startYear,
                                                        endYear: endYear,
                                                        language: language,
                                                        filterType: filterType,
                                                        openAccess: openAccess,
                                                        sortOrder: sortOrder
                                                    };
                                                    results = FilterEngine.applyAllFilters(results, filters);
                                                }
                                            } catch (filterError) {
                                                console.error('❌ Ошибка при применении фильтров:', filterError);
                                            }
                                        }
                                        
                                        console.log('Ограниченный запрос успешен, получено результатов:', results.length);
                                        return results;
                                }
                            } catch (limitedError) {
                                console.warn('Ограниченный запрос также не удался:', limitedError);
                            }
                            
                            throw new Error('Превышен лимит запросов к OpenAlex API. Пожалуйста, подождите 5-10 минут и повторите запрос.');
                        } else if (response.status === 400) {
                            throw new Error('Ошибка в параметрах поиска. Возможные причины:\n\n' +
                                '• Неправильно указаны параметры поиска\n' +
                                '• Неподдерживаемые символы в ключевых словах\n' +
                                '• Слишком строгие фильтры\n\n' +
                                'Попробуйте:\n' +
                                '• Упростить поисковый запрос\n' +
                                '• Изменить фильтры\n' +
                                '• Проверить корректность введенных данных');
                        } else {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    }
                } catch (error) {
                console.error('Ошибка при поиске в OpenAlex:', error);
                
                // Последняя попытка - самый простой запрос без всех фильтров
                if (error.message.includes('OpenAlex API временно недоступен') || 
                    error.message.includes('Failed to fetch') || 
                    error.name === 'TypeError') {
                    
                    console.log('🔄 Пробуем последний fallback - самый простой запрос...');
                    
                    try {
                        const simplestUrl = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=10&data_version=2`;
                        
                        console.log('Простейший URL:', simplestUrl);
                        
                        const simplestResponse = await fetch(simplestUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                                }
                            });
                            
                        if (simplestResponse.ok) {
                            const simplestData = await simplestResponse.json();
                            let simpleResults = simplestData.results || [];
                            
                            console.log(`✅ Простейший запрос успешен, получено ${simpleResults.length} результатов`);
                            
                            // Применяем СТРОГУЮ фильтрацию через FilterEngine
                            const originalCount = simpleResults.length;
                            if (Array.isArray(simpleResults) && simpleResults.length > 0) {
                                try {
                                    if (typeof FilterEngine !== 'undefined' && FilterEngine.applyAllFilters) {
                                        const filters = {
                                            startYear: startYear,
                                            endYear: endYear,
                                            language: language,
                                            filterType: filterType,
                                            openAccess: openAccess,
                                            sortOrder: sortOrder
                                        };
                                        simpleResults = FilterEngine.applyAllFilters(simpleResults, filters);
                                        console.log(`✅ Фильтрация применена: ${originalCount} → ${simpleResults.length}`);
                                    }
                                } catch (filterError) {
                                    console.error('❌ Ошибка при применении фильтров:', filterError);
                                }
                            }
                            
                            // Ограничиваем количество результатов
                            simpleResults = simpleResults.slice(0, targetResults);
                            
                            console.log(`После строгой фильтрации: ${originalCount} → ${simpleResults.length} результатов`);
                            
                            // Добавляем информационное сообщение
                            if (simpleResults.length > 0) {
                                simpleResults[0]._info = `✅ Применена полная строгая клиентская фильтрация (fallback режим). Показано ${simpleResults.length} результатов из ${originalCount}.`;
                            }
                            
                            return simpleResults;
                        } else {
                            console.error(`Простейший запрос также не удался: ${simplestResponse.status}`);
                        }
                    } catch (simpleError) {
                        console.error('Ошибка простейшего запроса:', simpleError);
                    }
                }
                
                // Если все методы не работают
                    if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                        throw new Error('Ошибка сетевого подключения. Возможные причины:\n\n' +
                            '• Проблемы с интернет-соединением\n' +
                            '• Блокировка CORS политиками браузера\n' +
                            '• Блокировка антивирусом или файрволом\n' +
                            '• Временные проблемы с OpenAlex сервером\n\n' +
                            'Попробуйте:\n' +
                            '• Проверить интернет-соединение\n' +
                            '• Отключить VPN или антивирус временно\n' +
                            '• Попробовать другой браузер\n' +
                            '• Обратиться к разработчику: pavel.alekseev.gasu@gmail.com');
                    }
                    
                    throw error;
                }
            }








            displayResults(results) {
                this.results = results;
                this.selectedResults.clear();
                const resultsPanel = document.getElementById('resultsPanel');
                const resultsList = document.getElementById('resultsList');
                const resultsCount = document.getElementById('resultsCount');
                const selectionControls = document.getElementById('selectionControls');

                resultsPanel.style.display = 'block';
                resultsPanel.classList.add('active');
                
                // Показываем информацию о результатах
                let countText = `Найдено результатов: ${results.length}`;
                resultsCount.textContent = countText;

                // Показываем элементы управления выбором
                if (selectionControls) {
                    selectionControls.style.display = 'flex';
                }

                if (results.length === 0) {
                    resultsList.innerHTML = '<div class="no-results">Результаты не найдены. Попробуйте изменить параметры поиска.</div>';
                    return;
                }

                // Проверяем наличие информационных сообщений и предупреждений
                let infoHtml = '';
                if (results.length > 0) {
                    if (results[0]._info) {
                        infoHtml = `<div class="info" style="margin-bottom: 15px; background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; border-radius: 8px; padding: 12px;">
                            <strong>ℹ️ Информация:</strong> ${results[0]._info}
                        </div>`;
                    } else if (results[0]._warning) {
                        infoHtml = `<div class="warning" style="margin-bottom: 15px; background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; border-radius: 8px; padding: 12px;">
                        <strong>⚠️ Внимание:</strong> ${results[0]._warning}
                    </div>`;
                    }
                }

                try {
                    // Отображаем все результаты сразу
                    resultsList.innerHTML = infoHtml + results.map((work, index) => this.formatResult(work, index + 1)).join('');
                    this.updateSelectionCount();
                    this.generateAnalytics(results);
                } catch (error) {
                    console.error('Ошибка при отображении результатов:', error);
                    console.error('Проблемный результат:', results.find((work, index) => {
                        try {
                            this.formatResult(work, index + 1);
                            return false;
                        } catch (e) {
                            console.error(`Ошибка в результате ${index + 1}:`, e);
                            return true;
                        }
                    }));
                    
                    resultsList.innerHTML = infoHtml + '<div class="error">Ошибка при отображении некоторых результатов. Проверьте консоль для подробностей.</div>';
                }
            }

            generateAnalytics(results) {
                if (results.length === 0) return;
                
                const analyticsPanel = document.getElementById('analyticsPanel');
                analyticsPanel.style.display = 'block';
                
                // Анализ авторов
                const authors = {};
                results.forEach(work => {
                    work.authorships?.forEach(authorship => {
                        const authorName = authorship?.author?.display_name;
                        if (authorName) {
                            authors[authorName] = (authors[authorName] || 0) + 1;
                        }
                    });
                });
                
                const topAuthors = Object.entries(authors)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5);
                
                document.getElementById('topAuthors').innerHTML = topAuthors
                    .map(([name, count]) => `
                        <div class="analytics-item">
                            <span>${name}</span>
                            <span>${count}</span>
                        </div>
                        <div class="analytics-bar">
                            <div class="analytics-bar-fill" style="width: ${(count / topAuthors[0][1]) * 100}%"></div>
                        </div>
                    `).join('');
                
                // Анализ журналов
                const journals = {};
                results.forEach(work => {
                    const journalName = work.primary_location?.source?.display_name;
                    if (journalName) {
                        journals[journalName] = (journals[journalName] || 0) + 1;
                    }
                });
                
                const topJournals = Object.entries(journals)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5);
                
                document.getElementById('topJournals').innerHTML = topJournals
                    .map(([name, count]) => `
                        <div class="analytics-item">
                            <span>${name.length > 30 ? name.substring(0, 30) + '...' : name}</span>
                            <span>${count}</span>
                        </div>
                        <div class="analytics-bar">
                            <div class="analytics-bar-fill" style="width: ${(count / topJournals[0][1]) * 100}%"></div>
                        </div>
                    `).join('');
                
                // Распределение по годам
                const years = {};
                results.forEach(work => {
                    const year = work.publication_year;
                    if (year) {
                        years[year] = (years[year] || 0) + 1;
                    }
                });
                
                const sortedYears = Object.entries(years)
                    .sort(([a], [b]) => b - a)
                    .slice(0, 5);
                
                document.getElementById('yearDistribution').innerHTML = sortedYears
                    .map(([year, count]) => `
                        <div class="analytics-item">
                            <span>${year}</span>
                            <span>${count}</span>
                        </div>
                        <div class="analytics-bar">
                            <div class="analytics-bar-fill" style="width: ${(count / sortedYears[0][1]) * 100}%"></div>
                        </div>
                    `).join('');
                
                // Статистика открытого доступа
                const openAccessCount = results.filter(work => work.open_access?.is_oa).length;
                const totalCount = results.length;
                const openAccessPercent = Math.round((openAccessCount / totalCount) * 100);
                
                // Логируем информацию об открытом доступе для диагностики
                console.log('=== АНАЛИЗ ОТКРЫТОГО ДОСТУПА ===');
                console.log(`Всего результатов: ${totalCount}`);
                console.log(`Открытый доступ: ${openAccessCount} (${openAccessPercent}%)`);
                console.log(`Платный доступ: ${totalCount - openAccessCount} (${100 - openAccessPercent}%)`);
                
                // Показываем примеры для каждого типа доступа
                const openAccessExamples = results.filter(work => work.open_access?.is_oa).slice(0, 3);
                const closedAccessExamples = results.filter(work => !work.open_access?.is_oa).slice(0, 3);
                
                console.log('Примеры открытого доступа:', openAccessExamples.map(w => ({
                    title: w.title?.substring(0, 50) + '...',
                    is_oa: w.open_access?.is_oa,
                    oa_url: w.open_access?.oa_url,
                    oa_status: w.open_access?.oa_status
                })));
                
                console.log('Примеры платного доступа:', closedAccessExamples.map(w => ({
                    title: w.title?.substring(0, 50) + '...',
                    is_oa: w.open_access?.is_oa,
                    oa_url: w.open_access?.oa_url,
                    oa_status: w.open_access?.oa_status
                })));
                
                console.log('=== КОНЕЦ АНАЛИЗА ОТКРЫТОГО ДОСТУПА ===');
                
                document.getElementById('openAccessStats').innerHTML = `
                    <div class="analytics-item">
                        <span>Открытый доступ</span>
                        <span>${openAccessCount} (${openAccessPercent}%)</span>
                    </div>
                    <div class="analytics-bar">
                        <div class="analytics-bar-fill" style="width: ${openAccessPercent}%"></div>
                    </div>
                    <div class="analytics-item">
                        <span>Платный доступ</span>
                        <span>${totalCount - openAccessCount} (${100 - openAccessPercent}%)</span>
                    </div>
                    <div class="analytics-bar">
                        <div class="analytics-bar-fill" style="width: ${100 - openAccessPercent}%; background: var(--accent-secondary);"></div>
                    </div>
                `;
            }

            // Функция для безопасного отображения HTML-контента
            sanitizeHtml(html) {
                if (!html) return '';
                
                // Простая очистка HTML - удаляем потенциально опасные теги
                // и оставляем только безопасные теги форматирования
                let cleanedHtml = html
                    // Удаляем потенциально опасные теги
                    .replace(/<script[^>]*>.*?<\/script>/gi, '')
                    .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '')
                    .replace(/<object[^>]*>.*?<\/object>/gi, '')
                    .replace(/<embed[^>]*>.*?<\/embed>/gi, '')
                    .replace(/<link[^>]*>/gi, '')
                    .replace(/<meta[^>]*>/gi, '')
                    .replace(/<style[^>]*>.*?<\/style>/gi, '')
                    // Удаляем атрибуты onclick, onload и другие события
                    .replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '')
                    // Удаляем javascript: ссылки
                    .replace(/javascript:/gi, '')
                    // Очищаем пустые теги
                    .replace(/<(\w+)[^>]*>\s*<\/\1>/gi, '')
                    // Удаляем пустые параграфы
                    .replace(/<p[^>]*>\s*<\/p>/gi, '')
                    // Удаляем пустые span'ы
                    .replace(/<span[^>]*>\s*<\/span>/gi, '');
                
                // Если после очистки остались только пустые теги, возвращаем текст без тегов
                const textOnly = cleanedHtml.replace(/<[^>]*>/g, '').trim();
                if (textOnly.length === 0) {
                    return '';
                }
                
                return cleanedHtml;
            }

            formatResult(work, index) {
                console.log(`\n=== FORMATTING RESULT ${index} ===`);
                console.log('Work object:', work);
                console.log('Work keys:', Object.keys(work));
                console.log('Biblio data:', work.biblio);
                console.log('Page info:', {
                    first_page: work.biblio?.first_page,
                    last_page: work.biblio?.last_page,
                    pages: work.pages
                });
                console.log('Authorships:', work.authorships);
                console.log('Primary location:', work.primary_location);
                
                const title = work.title || 'Без названия';
                
                console.log('=== ОТЛАДКА АВТОРОВ ===');
                console.log('Work data for authors:', work);
                console.log('Authorships:', work.authorships);
                console.log('Authorships type:', typeof work.authorships);
                console.log('Authorships is array:', Array.isArray(work.authorships));
                console.log('Authorships length:', work.authorships?.length);
                
                if (work.authorships && work.authorships.length > 0) {
                    console.log('First authorship:', work.authorships[0]);
                    console.log('First authorship keys:', Object.keys(work.authorships[0]));
                    console.log('First authorship author:', work.authorships[0].author);
                    if (work.authorships[0].author) {
                        console.log('First author keys:', Object.keys(work.authorships[0].author));
                        console.log('First author display_name:', work.authorships[0].author.display_name);
                    }
                }
                
                console.log('Work.authors:', work.authors);
                console.log('Work.author:', work.author);
                console.log('All work keys:', Object.keys(work));
                
                let authors = 'Авторы не указаны';
                
                // Улучшенное извлечение авторов с проверкой всех возможных структур
                if (work.authorships && Array.isArray(work.authorships) && work.authorships.length > 0) {
                    const authorNames = work.authorships
                        .map(authorship => {
                            // Проверяем все возможные пути к имени автора
                            if (authorship?.author) {
                                return authorship.author.display_name || 
                                       authorship.author.name ||
                                       authorship.author.title ||
                                       (authorship.author.display_name_alternatives && authorship.author.display_name_alternatives[0]) ||
                                       authorship.author.id?.split('/').pop(); // fallback на ID
                            }
                            // Если author - это объект напрямую
                            return authorship?.display_name || 
                                   authorship?.name ||
                                   authorship?.title ||
                                   authorship?.display_name_alternatives?.[0];
                        })
                        .filter(name => name && name.trim() !== '');
                    
                    if (authorNames.length > 0) {
                        authors = authorNames.join(', ');
                    }
                } 
                
                // Если авторы не найдены через authorships, проверяем альтернативные варианты
                if (authors === 'Авторы не указаны') {
                    if (work.authors && Array.isArray(work.authors) && work.authors.length > 0) {
                    const authorNames = work.authors
                            .map(author => {
                                if (typeof author === 'string') return author;
                                return author?.display_name || author?.name || author?.title || author?.id?.split('/').pop();
                            })
                        .filter(name => name && name.trim() !== '');
                    
                    if (authorNames.length > 0) {
                        authors = authorNames.join(', ');
                    }
                } else if (work.author) {
                    // Единичный автор
                        if (typeof work.author === 'string') {
                            authors = work.author;
                } else {
                            authors = work.author.display_name || 
                                     work.author.name || 
                                     work.author.title || 
                                     work.author.id?.split('/').pop() ||
                                     'Автор не указан';
                        }
                    } else {
                        // Проверяем другие возможные поля из API OpenAlex
                    const possibleAuthorFields = [
                            'concepts', // иногда авторы могут быть в concepts
                            'mesh', // медицинские термины могут содержать авторов
                        ];
                        
                        // Также проверяем в primary_location
                        if (work.primary_location?.source?.host_organization_name) {
                            // Это не автор, но может быть полезно
                        }
                        
                        // Проверяем в locations
                        if (work.locations && Array.isArray(work.locations)) {
                            const locationAuthors = work.locations
                                .map(loc => loc?.source?.display_name)
                                .filter(name => name && name.trim() !== '');
                            
                            if (locationAuthors.length === 0 && work.authorships) {
                                // Если authorships пустой массив, значит авторы действительно не указаны
                                console.log('authorships существует, но пустой - авторы не указаны в API');
                            }
                        }
                    }
                }
                
                // Финальная проверка - если всё ещё нет авторов, пытаемся достать из любого места
                if (authors === 'Авторы не указаны' && work.authorships && work.authorships.length === 0) {
                    console.warn('authorships пустой массив - авторы действительно не указаны в API OpenAlex');
                }
                
                console.log('Final authors:', authors);
                const journal = work.primary_location?.source?.display_name || 'Журнал не указан';
                const year = work.publication_year || 'Год не указан';
                    
                    // Улучшенное извлечение аннотации
                    console.log('Abstract fields available:', {
                        'abstract_inverted_index': work.abstract_inverted_index,
                        'abstract': work.abstract,
                        'description': work.description,
                        'summary': work.summary
                    });
                    
                let abstract;
                    if (work.abstract_inverted_index) {
                        abstract = this.reconstructAbstract(work.abstract_inverted_index);
                        console.log('Reconstructed abstract length:', abstract.length);
                    } else if (work.abstract) {
                        abstract = work.abstract;
                        console.log('Direct abstract length:', abstract.length);
                    } else if (work.description) {
                        abstract = work.description;
                        console.log('Description used as abstract, length:', abstract.length);
                    } else if (work.summary) {
                        abstract = work.summary;
                        console.log('Summary used as abstract, length:', abstract.length);
                    } else {
                        abstract = 'Аннотация недоступна';
                        console.log('No abstract found');
                    }
                    
                const doi = work.doi;
                const linkUrl = work.landing_page_url || work.id || '#';

                const resultIndex = index - 1;
                
                return `
                    <div class="result-item" data-index="${resultIndex}">
                            <input type="checkbox" class="result-checkbox" data-index="${resultIndex}" onchange="window.sciSearcher.toggleSelection(${resultIndex})">
                        <div class="result-title">${title}</div>
                        <div class="result-authors">${authors}</div>
                        <div class="result-journal">${journal}</div>
                        <div class="result-year">Год: ${year}</div>
                        ${work.biblio?.first_page ? `
                            <div class="result-pages" style="color: #27ae60; font-size: 0.8rem; margin-bottom: 6px;">
                                📄 Страницы: ${work.biblio.first_page}${work.biblio.last_page && work.biblio.first_page !== work.biblio.last_page ? `–${work.biblio.last_page}` : ''}
                            </div>
                        ` : work.biblio?.volume ? `
                            <div class="result-pages" style="color: #f39c12; font-size: 0.8rem; margin-bottom: 6px;">
                                📖 Том ${work.biblio.volume}${work.biblio.issue ? `, № ${work.biblio.issue}` : ''} (страницы не указаны)
                            </div>
                        ` : ''}
                        ${abstract && abstract !== 'Аннотация недоступна' ? `
                            <div class="result-abstract abstract-preview" id="abstract-${resultIndex}">
                                ${this.sanitizeHtml(abstract)}
                            </div>
                                <button class="toggle-abstract" onclick="window.sciSearcher.toggleAbstract(${resultIndex})">
                                    Показать полностью
                                </button>
                        ` : ''}
                        ${doi ? `<div class="result-doi">DOI: <a href="${doi.startsWith('https://doi.org/') ? doi : `https://doi.org/${doi}`}" target="_blank">${doi.replace('https://doi.org/', '')}</a></div>` : ''}
                        <a href="${linkUrl}" target="_blank" class="result-link">
                            🔗 Перейти к статье
                        </a>
                    </div>
                `;
            }

            reconstructAbstract(abstractIndex) {
                if (!abstractIndex) return 'Аннотация недоступна';
                
                console.log('Reconstructing abstract from index:', abstractIndex);
                
                try {
                    const words = [];
                    for (const [word, positions] of Object.entries(abstractIndex)) {
                        if (Array.isArray(positions)) {
                            positions.forEach(pos => {
                                words[pos] = word;
                            });
                        }
                    }
                    
                    // Фильтруем пустые слоты и соединяем слова
                    const fullText = words.filter(word => word !== undefined).join(' ');
                    console.log('Reconstructed abstract full text length:', fullText.length);
                    console.log('First 200 chars:', fullText.substring(0, 200));
                    
                    return fullText || 'Аннотация недоступна';
                } catch (error) {
                    console.error('Error reconstructing abstract:', error);
                    return 'Ошибка при восстановлении аннотации';
                }
            }

            toggleSelection(index) {
                const checkbox = document.querySelector(`input[data-index="${index}"]`);
                const resultItem = document.querySelector(`.result-item[data-index="${index}"]`);
                
                if (checkbox.checked) {
                    this.selectedResults.add(index);
                    resultItem.classList.add('selected');
                } else {
                    this.selectedResults.delete(index);
                    resultItem.classList.remove('selected');
                }
                
                this.updateSelectionCount();
            }

            toggleAbstract(index) {
                const abstractElement = document.getElementById(`abstract-${index}`);
                const button = document.querySelector(`button[onclick="window.sciSearcher.toggleAbstract(${index})"]`);
                
                if (abstractElement.classList.contains('abstract-preview')) {
                    abstractElement.classList.remove('abstract-preview');
                    abstractElement.classList.add('abstract-full');
                    button.textContent = 'Свернуть';
                } else {
                    abstractElement.classList.remove('abstract-full');
                    abstractElement.classList.add('abstract-preview');
                    button.textContent = 'Показать полностью';
                }
            }

            selectAllResults() {
                this.selectedResults.clear();
                const checkboxes = document.querySelectorAll('.result-checkbox');
                const resultItems = document.querySelectorAll('.result-item');
                
                checkboxes.forEach((checkbox, index) => {
                    checkbox.checked = true;
                    this.selectedResults.add(index);
                    resultItems[index].classList.add('selected');
                });
                
                this.updateSelectionCount();
            }

            clearSelection() {
                this.selectedResults.clear();
                const checkboxes = document.querySelectorAll('.result-checkbox');
                const resultItems = document.querySelectorAll('.result-item');
                
                checkboxes.forEach((checkbox, index) => {
                    checkbox.checked = false;
                    resultItems[index].classList.remove('selected');
                });
                
                this.updateSelectionCount();
            }

            updateSelectionCount() {
                const selectedCount = document.getElementById('selectedCount');
                const selectAllCheckbox = document.getElementById('selectAllCheckbox');
                const downloadSelectedApaBtn = document.getElementById('downloadSelectedApaBtn');
                const downloadSelectedGostBtn = document.getElementById('downloadSelectedGostBtn');
                const downloadSelectedTxtBtn = document.getElementById('downloadSelectedTxtBtn');
                
                if (selectedCount) {
                    selectedCount.textContent = `Выбрано: ${this.selectedResults.size}`;
                }
                
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = this.selectedResults.size === this.results.length && this.results.length > 0;
                }
                
                // Показываем/скрываем кнопки скачивания в зависимости от количества выбранных
                const hasSelected = this.selectedResults.size > 0;
                if (downloadSelectedApaBtn) downloadSelectedApaBtn.style.display = hasSelected ? 'flex' : 'none';
                if (downloadSelectedGostBtn) downloadSelectedGostBtn.style.display = hasSelected ? 'flex' : 'none';
                if (downloadSelectedTxtBtn) downloadSelectedTxtBtn.style.display = hasSelected ? 'flex' : 'none';
            }

            downloadSelectedResults(format = 'txt') {
                if (this.selectedResults.size === 0) {
                    alert('Выберите хотя бы одну публикацию для скачивания.\n\nИспользуйте чекбоксы рядом с публикациями для выбора.');
                    return;
                }
                
                const selectedResults = Array.from(this.selectedResults).map(index => this.results[index]);
                console.log(`Скачивание ${selectedResults.length} выбранных публикаций в формате ${format.toUpperCase()}`);
                this.downloadResults(format, selectedResults);
            }

            showLoading() {
                const resultsPanel = document.getElementById('resultsPanel');
                const resultsList = document.getElementById('resultsList');
                
                if (!resultsPanel || !resultsList) {
                    console.error('Элементы результатов не найдены при попытке показать загрузку');
                    return;
                }
                
                const resultsLimit = document.getElementById('resultsLimit')?.value || 50;
                
                resultsPanel.style.display = 'block';
                resultsPanel.classList.add('active');
                
                let loadingMessage = 'Поиск научных публикаций...';
                const limit = parseInt(resultsLimit) || 50;
                
                if (limit >= 300) {
                    loadingMessage = `Поиск большого количества публикаций (до ${limit})...<br><small style="color: #666;">Это может занять 30-60 секунд</small>`;
                } else if (limit >= 200) {
                    loadingMessage = `Поиск публикаций (до ${limit})...<br><small style="color: #666;">Это может занять 15-30 секунд</small>`;
                } else if (limit >= 100) {
                    loadingMessage = `Поиск публикаций (до ${limit})...<br><small style="color: #666;">Это может занять 10-20 секунд</small>`;
                } else {
                    loadingMessage = `Поиск публикаций (до ${limit})...`;
                }
                
                resultsList.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <div>${loadingMessage}</div>
                    </div>
                `;
            }

            showError(message) {
                console.error('Показываем ошибку:', message);
                
                const resultsPanel = document.getElementById('resultsPanel');
                const resultsList = document.getElementById('resultsList');
                
                if (!resultsPanel || !resultsList) {
                    alert('Ошибка: ' + message);
                    console.error('Элементы результатов не найдены при показе ошибки');
                    return;
                }
                
                resultsPanel.style.display = 'block';
                resultsPanel.classList.add('active');
                
                resultsList.innerHTML = `
                    <div class="error">
                        <strong>❌ Ошибка при поиске</strong><br><br>
                        ${message.replace(/\n/g, '<br>')}
                        <div style="margin-top: 15px;">
                            <button class="search-btn" onclick="window.sciSearcher?.retrySearch()" style="margin-right: 10px;">
                                🔄 Попробовать снова
                            </button>
                            <button class="search-btn" onclick="window.sciSearcher?.tryAlternativeSearch()" style="background: #28a745; margin-right: 10px;">
                                🔍 Альтернативный поиск (25 результатов)
                            </button>
                            <button class="search-btn" onclick="window.sciSearcher?.searchWithoutYearFilters()" style="background: #6f42c1; margin-right: 10px;">
                                📅 Поиск без фильтров по годам
                            </button>
                            <button class="search-btn" onclick="window.sciSearcher?.runDiagnostics()" style="background: #17a2b8;">
                                🔧 Диагностика
                            </button>
                        </div>
                    </div>
                `;
            }

            downloadResults(format = 'txt', selectedResults = null) {
                const resultsToDownload = selectedResults || this.results;
                
                if (resultsToDownload.length === 0) {
                    alert('Нет результатов для скачивания');
                    return;
                }

                let text, filename;
                
                switch(format) {
                    case 'apa':
                        text = this.formatResultsForAPA(resultsToDownload);
                        filename = `sci-search-results-apa-${new Date().toISOString().split('T')[0]}.txt`;
                        break;
                    case 'gost':
                        text = this.formatResultsForGOST(resultsToDownload);
                        filename = `sci-search-results-gost-${new Date().toISOString().split('T')[0]}.txt`;
                        break;
                    case 'bibtex':
                        text = this.formatResultsForBibTeX(resultsToDownload);
                        filename = `sci-search-results-bibtex-${new Date().toISOString().split('T')[0]}.bib`;
                        break;
                    default:
                        text = this.formatResultsForExport(resultsToDownload);
                        filename = `sci-search-results-${new Date().toISOString().split('T')[0]}.txt`;
                }

                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            copyResults() {
                if (this.results.length === 0) {
                    alert('Нет результатов для копирования');
                    return;
                }

                const text = this.formatResultsForExport();
                navigator.clipboard.writeText(text).then(() => {
                    alert('Результаты скопированы в буфер обмена!');
                }).catch(err => {
                    console.error('Ошибка копирования: ', err);
                    alert('Ошибка при копировании. Попробуйте скачать файл.');
                });
            }

            formatResultsForExport(results = null) {
                const resultsToFormat = results || this.results;
                const keywords = document.getElementById('keywords').value;
                const startYear = document.getElementById('startYear').value;
                const endYear = document.getElementById('endYear').value;
                
                let text = `РЕЗУЛЬТАТЫ ПОИСКА НАУЧНОЙ ЛИТЕРАТУРЫ\n`;
                text += `Ключевые слова: ${keywords}\n`;
                if (startYear || endYear) {
                    text += `Период: ${startYear || 'не указан'} - ${endYear || 'не указан'}\n`;
                }
                text += `Дата поиска: ${new Date().toLocaleString('ru-RU')}\n`;
                text += `Найдено результатов: ${resultsToFormat.length}\n\n`;
                text += `========================================\n\n`;

                resultsToFormat.forEach((work, index) => {
                    const title = work.title || 'Без названия';
                    
                    // Улучшенное извлечение авторов для экспорта
                    let authors = 'Авторы не указаны';
                    
                    if (work.authorships && work.authorships.length > 0) {
                        const authorNames = work.authorships
                            .map(authorship => authorship?.author?.display_name || 
                                               authorship?.author?.name ||
                                               authorship?.author?.title ||
                                               authorship?.display_name)
                            .filter(name => name && name.trim() !== '');
                        
                        if (authorNames.length > 0) {
                            authors = authorNames.join(', ');
                        }
                    } else if (work.authors && work.authors.length > 0) {
                        const authorNames = work.authors
                            .map(author => author?.display_name || author?.name || author?.title)
                            .filter(name => name && name.trim() !== '');
                        
                        if (authorNames.length > 0) {
                            authors = authorNames.join(', ');
                        }
                    } else if (work.author) {
                        authors = work.author.display_name || work.author.name || work.author.title || 'Автор не указан';
                    }
                    
                    const journal = work.primary_location?.source?.display_name || 'Журнал не указан';
                    const year = work.publication_year || 'Год не указан';
                    const doi = work.doi || work.id;

                    text += `${index + 1}. ${title}\n`;
                    text += `Авторы: ${authors}\n`;
                    text += `Журнал: ${journal}\n`;
                    text += `Год: ${year}\n`;
                    text += `DOI: ${doi}\n\n`;
                });

                return text;
            }

            formatResultsForAPA(results = null) {
                const resultsToFormat = results || this.results;
                    const keywords = document.getElementById('keywords').value;
                    const startYear = document.getElementById('startYear').value;
                    const endYear = document.getElementById('endYear').value;
                
                let searchInfo = `Search keywords: ${keywords}\n`;
                    if (startYear || endYear) {
                        searchInfo += `Publication period: ${startYear || 'not specified'} - ${endYear || 'not specified'}\n`;
                }
                
                let text = `REFERENCES (APA FORMAT)\n`;
                text += searchInfo;
                text += `Search date: ${new Date().toLocaleString('en-US')}\n`;
                text += `Total results: ${resultsToFormat.length}\n\n`;

                resultsToFormat.forEach((work, index) => {
                    const title = work.title || 'Untitled';
                    const year = work.publication_year || work.year || 'n.d.';
                    const doi = work.doi || '';
                    const volume = work.biblio?.volume || work.volume || '';
                    const issue = work.biblio?.issue || work.issue || '';
                    // Format pages with range (first_page - last_page)
                    // OpenAlex API provides first_page and last_page in biblio object
                    // If both are available and different, show range (e.g., "215–220")
                    // If only first_page is available, show single page
                    // If no page info is available, pages remains empty
                    let pages = '';
                    const firstPage = work.biblio?.first_page || '';
                    const lastPage = work.biblio?.last_page || '';
                    if (firstPage && lastPage && firstPage !== lastPage) {
                        pages = `${firstPage}–${lastPage}`;
                    } else if (firstPage) {
                        pages = firstPage;
                    } else if (work.pages) {
                        pages = work.pages;
                    }

                    // Format authors in APA style with better null checks
                    let authorString = '';
                    const authors = work.authorships || [];
                    
                    if (authors.length === 0) {
                        // Попробуем альтернативные источники авторов
                        if (work.authors && work.authors.length > 0) {
                            const validAuthors = work.authors
                                .map(author => author?.display_name || author?.name || author?.title)
                                .filter(name => name && name.trim() !== '');
                            
                            if (validAuthors.length > 0) {
                                if (validAuthors.length === 1) {
                                    const name = validAuthors[0];
                                    const lastName = name.split(',')[0] || name.split(' ').pop();
                                    const firstName = name.split(',')[1]?.trim() || name.split(' ')[0];
                                    authorString = `${lastName}, ${firstName.charAt(0).toUpperCase()}.`;
                                } else if (validAuthors.length <= 7) {
                                    const formattedAuthors = validAuthors.map(name => {
                                        const lastName = name.split(',')[0] || name.split(' ').pop();
                                        const firstName = name.split(',')[1]?.trim() || name.split(' ')[0];
                                        return `${lastName}, ${firstName.charAt(0).toUpperCase()}.`;
                                    });
                                    authorString = formattedAuthors.join(', ');
                                } else {
                                    const firstAuthor = validAuthors[0];
                                    const lastName = firstAuthor.split(',')[0] || firstAuthor.split(' ').pop();
                                    const firstName = firstAuthor.split(',')[1]?.trim() || firstAuthor.split(' ')[0];
                                    authorString = `${lastName}, ${firstName.charAt(0).toUpperCase()}., et al.`;
                                }
                            } else {
                                authorString = 'Anonymous';
                            }
                        } else {
                            authorString = 'Anonymous';
                        }
                    } else {
                        const validAuthors = authors
                            .map(authorship => authorship?.author?.display_name || 
                                               authorship?.author?.name ||
                                               authorship?.author?.title ||
                                               authorship?.display_name)
                            .filter(name => name && name.trim() !== '');
                        
                        if (validAuthors.length === 0) {
                            authorString = 'Anonymous';
                        } else if (validAuthors.length === 1) {
                            const name = validAuthors[0];
                            const lastName = name.split(',')[0] || name.split(' ').pop();
                            const firstName = name.split(',')[1]?.trim() || name.split(' ')[0];
                            authorString = `${lastName}, ${firstName.charAt(0).toUpperCase()}.`;
                        } else if (validAuthors.length <= 7) {
                            const formattedAuthors = validAuthors.map(name => {
                                const lastName = name.split(',')[0] || name.split(' ').pop();
                                const firstName = name.split(',')[1]?.trim() || name.split(' ')[0];
                                return `${lastName}, ${firstName.charAt(0).toUpperCase()}.`;
                            });
                            authorString = formattedAuthors.join(', ');
                        } else {
                            const firstAuthor = validAuthors[0];
                            const lastName = firstAuthor.split(',')[0] || firstAuthor.split(' ').pop();
                            const firstName = firstAuthor.split(',')[1]?.trim() || firstAuthor.split(' ')[0];
                            authorString = `${lastName}, ${firstName.charAt(0).toUpperCase()}., et al.`;
                        }
                    }

                    // Format journal info
                    const journal = work.primary_location?.source?.display_name || 'Unknown Journal';
                    let journalInfo = journal;
                    if (volume) {
                        journalInfo += `, ${volume}`;
                        if (issue) {
                            journalInfo += `(${issue})`;
                        }
                        if (pages) {
                            journalInfo += `, ${pages}`;
                        } else {
                            // Если есть том/номер, но нет страниц, добавляем примечание
                            journalInfo += `, [pages not specified]`;
                        }
                    }

                    // Construct APA reference
                    text += `${authorString} (${year}). ${title}. ${journalInfo}`;
                    if (doi) {
                        // Убираем дублирование https://doi.org/ если оно уже есть
                        const cleanDoi = doi.startsWith('https://doi.org/') ? doi : `https://doi.org/${doi}`;
                        text += `. ${cleanDoi}`;
                    }
                    text += '.\n\n';
                });

                return text;
            }


            formatResultsForGOST(results = null) {
                const resultsToFormat = results || this.results;
                    const keywords = document.getElementById('keywords').value;
                    const startYear = document.getElementById('startYear').value;
                    const endYear = document.getElementById('endYear').value;
                
                let searchInfo = `Ключевые слова поиска: ${keywords}\n`;
                    if (startYear || endYear) {
                        searchInfo += `Период публикации: ${startYear || 'не указан'} - ${endYear || 'не указан'}\n`;
                }
                
                let text = `СПИСОК ЛИТЕРАТУРЫ (ГОСТ 7.1-2003)\n`;
                text += searchInfo;
                text += `Дата поиска: ${new Date().toLocaleString('ru-RU')}\n`;
                text += `Всего результатов: ${resultsToFormat.length}\n\n`;

                resultsToFormat.forEach((work, index) => {
                    const title = work.title || 'Без названия';
                    const year = work.publication_year || work.year || 'б.г.';
                    const doi = work.doi || '';
                    const volume = work.biblio?.volume || work.volume || '';
                    const issue = work.biblio?.issue || work.issue || '';
                    // Format pages with range (first_page - last_page)
                    // OpenAlex API provides first_page and last_page in biblio object
                    // If both are available and different, show range (e.g., "215–220")
                    // If only first_page is available, show single page
                    // If no page info is available, pages remains empty
                    let pages = '';
                    const firstPage = work.biblio?.first_page || '';
                    const lastPage = work.biblio?.last_page || '';
                    if (firstPage && lastPage && firstPage !== lastPage) {
                        pages = `${firstPage}–${lastPage}`;
                    } else if (firstPage) {
                        pages = firstPage;
                    } else if (work.pages) {
                        pages = work.pages;
                    }

                    // Format authors in GOST style with better null checks
                    let authorString = '';
                    const authors = work.authorships || [];
                    
                    if (authors.length === 0) {
                        authorString = 'Аноним';
                    } else {
                        const validAuthors = authors
                            .map(authorship => authorship?.author?.display_name)
                            .filter(name => name && name.trim() !== '');
                        
                        if (validAuthors.length === 0) {
                            authorString = 'Аноним';
                        } else if (validAuthors.length === 1) {
                            authorString = validAuthors[0];
                        } else if (validAuthors.length <= 3) {
                            authorString = validAuthors.join(', ');
                        } else {
                            authorString = `${validAuthors[0]} [и др.]`;
                        }
                    }

                    // Format journal info
                    const journal = work.primary_location?.source?.display_name || 'Неизвестный журнал';
                    let journalInfo = journal;
                    if (volume) {
                        journalInfo += `. – ${year}. – Т. ${volume}`;
                        if (issue) {
                            journalInfo += `, № ${issue}`;
                        }
                        if (pages) {
                            journalInfo += `. – С. ${pages}`;
                        } else {
                            // Если есть том/номер, но нет страниц, добавляем примечание
                            journalInfo += `. – [Страницы не указаны]`;
                        }
                    } else {
                        journalInfo += `. – ${year}`;
                    }

                    // Construct GOST reference
                    text += `${authorString} ${title} // ${journalInfo}`;
                    if (doi) {
                        // Убираем дублирование https://doi.org/ если оно уже есть
                        const cleanDoi = doi.startsWith('https://doi.org/') ? doi : `https://doi.org/${doi}`;
                        text += `. – DOI: ${cleanDoi}`;
                    }
                    text += '.\n\n';
                });

                return text;
            }

            formatResultsForBibTeX(results = null) {
                const resultsToFormat = results || this.results;
                
                let text = `% BibTeX entries generated by Sci-Searcher\n`;
                text += `% Generated on: ${new Date().toLocaleString('en-US')}\n`;
                text += `% Total entries: ${resultsToFormat.length}\n\n`;

                resultsToFormat.forEach((work, index) => {
                    const title = work.title || 'Untitled';
                    const year = work.publication_year || work.year || 'n.d.';
                    const doi = work.doi || '';
                    const volume = work.biblio?.volume || work.volume || '';
                    const issue = work.biblio?.issue || work.issue || '';
                    
                    // Format pages with range
                    let pages = '';
                    const firstPage = work.biblio?.first_page || '';
                    const lastPage = work.biblio?.last_page || '';
                    if (firstPage && lastPage && firstPage !== lastPage) {
                        pages = `${firstPage}--${lastPage}`;
                    } else if (firstPage) {
                        pages = firstPage;
                    } else if (work.pages) {
                        pages = work.pages;
                    }

                    // Format authors
                    let authorString = '';
                    const authors = work.authorships || [];
                    
                    if (authors.length === 0) {
                        authorString = 'Anonymous';
                    } else {
                        const validAuthors = authors
                            .map(authorship => authorship?.author?.display_name)
                            .filter(name => name && name.trim() !== '');
                        
                        if (validAuthors.length === 0) {
                            authorString = 'Anonymous';
                        } else {
                            authorString = validAuthors.join(' and ');
                        }
                    }

                    // Journal name
                    const journal = work.primary_location?.source?.display_name || 'Unknown Journal';
                    
                    // Generate BibTeX key
                    const bibtexKey = `work${index + 1}_${year}`;
                    
                    // Determine entry type
                    const sourceType = work.primary_location?.source?.type;
                    let entryType = 'article';
                    if (sourceType === 'book' || sourceType === 'monograph') {
                        entryType = 'book';
                    } else if (sourceType === 'proceedings') {
                        entryType = 'inproceedings';
                    }

                    text += `@${entryType}{${bibtexKey},\n`;
                    text += `  title = {${title}},\n`;
                    text += `  author = {${authorString}},\n`;
                    text += `  journal = {${journal}},\n`;
                    text += `  year = {${year}},\n`;
                    
                    if (volume) {
                        text += `  volume = {${volume}},\n`;
                    }
                    if (issue) {
                        text += `  number = {${issue}},\n`;
                    }
                    if (pages) {
                        text += `  pages = {${pages}},\n`;
                    }
                    if (doi) {
                        text += `  doi = {${doi}},\n`;
                    }
                    
                    text += `}\n\n`;
                });

                return text;
            }

            async checkApiStatus() {
                const statusElement = document.getElementById('apiStatus');
                
                // Если элемент не найден, просто выходим
                if (!statusElement) {
                    console.warn('Элемент apiStatus не найден в DOM, пропускаем проверку статуса API');
                    return;
                }
                
                try {
                    // Простой тестовый запрос к OpenAlex API
                    const response = await fetch('https://api.openalex.org/works?search=test&per-page=1', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                        }
                    });
                    
                    if (response.ok) {
                        statusElement.textContent = 'Подключен ✅';
                        statusElement.style.color = '#28a745';
                    } else if (response.status === 403) {
                        statusElement.textContent = 'Ограничен ⚠️';
                        statusElement.style.color = '#ffc107';
                    } else {
                        statusElement.textContent = 'Ошибка сервера ⚠️';
                        statusElement.style.color = '#ffc107';
                    }
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                        statusElement.textContent = 'Сетевая ошибка ❌';
                        statusElement.style.color = '#dc3545';
                    } else {
                        statusElement.textContent = 'Недоступен ❌';
                        statusElement.style.color = '#dc3545';
                    }
                }
            }

            retrySearch() {
                // Повторяем последний поиск
                const form = document.getElementById('openalexForm');
                const event = new Event('submit');
                form.dispatchEvent(event);
            }

            async tryAlternativeSearch() {
                // Пробуем альтернативный поиск с минимальными параметрами
                const keywords = document.getElementById('keywords').value.trim();
                
                if (!keywords) {
                    alert('Пожалуйста, введите ключевые слова для поиска');
                    return;
                }

                this.showLoading();
                
                try {
                    // Простой запрос без фильтров по годам и с минимальным количеством результатов
                    const url = `https://api.openalex.org/works?search=${encodeURIComponent(keywords)}&per-page=25&sort=publication_date:desc&data_version=2`;
                    
                    console.log('Альтернативный поиск URL:', url);
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Альтернативный поиск успешен:', data);
                        this.displayResults(data.results || []);
                } else {
                        throw new Error(`Альтернативный поиск также не удался. Статус: ${response.status}`);
                    }
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                        this.showError('Ошибка сетевого подключения. Возможные решения:\n\n' +
                            '• Проверить интернет-соединение\n' +
                            '• Отключить VPN или антивирус временно\n' +
                            '• Попробовать другой браузер\n' +
                            '• Проверить настройки файрвола\n' +
                            '• Попробовать позже или обратиться к разработчику\n' +
                            '• Контакты: pavel.alekseev.gasu@gmail.com');
                    } else {
                        this.showError('К сожалению, поиск временно недоступен. Возможные решения:\n\n' +
                            '• Подождать 10-15 минут и повторить попытку\n' +
                            '• Проверить интернет-соединение\n' +
                            '• Попробовать позже или обратиться к разработчику\n' +
                            '• Использовать VPN для смены IP-адреса');
                    }
                }
            }

            async searchWithoutYearFilters() {
                // Поиск без фильтров по годам
                const keywords = document.getElementById('keywords').value.trim();
                const resultsLimit = document.getElementById('resultsLimit').value;
                
                if (!keywords) {
                    alert('Пожалуйста, введите ключевые слова для поиска');
                    return;
                }

                this.showLoading();
                
                try {
                    // Поиск без фильтров по годам
                    const results = await this.searchOpenAlex(keywords, '', '', resultsLimit);
                    this.displayResults(results);
                } catch (error) {
                    this.showError('Ошибка при поиске без фильтров: ' + error.message);
                }
            }

            async runDiagnostics() {
                const resultsPanel = document.getElementById('resultsPanel');
                const resultsList = document.getElementById('resultsList');
                
                resultsList.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <div>Запуск диагностики...</div>
                    </div>
                `;
                
                const diagnostics = [];
                
                // Проверка 1: Базовое подключение к интернету
                try {
                    const testResponse = await fetch('https://httpbin.org/get', { method: 'GET' });
                    if (testResponse.ok) {
                        diagnostics.push('✅ Базовое интернет-соединение работает');
                    } else {
                        diagnostics.push('❌ Проблемы с базовым интернет-соединением');
                    }
                } catch (error) {
                    diagnostics.push('❌ Нет интернет-соединения');
                }
                
                // Проверка 2: Подключение к OpenAlex API (полный запрос)
                try {
                    const openAlexResponse = await fetch('https://api.openalex.org/works?search=test&per-page=1&data_version=2', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Sci-Searcher/1.0 (Educational Research Tool)'
                        }
                    });
                    
                    if (openAlexResponse.ok) {
                        const data = await openAlexResponse.json();
                        diagnostics.push(`✅ OpenAlex API доступен (получено ${data.results?.length || 0} результатов)`);
                    } else if (openAlexResponse.status === 403) {
                        diagnostics.push('⚠️ OpenAlex API ограничен (статус: 403) - возможно, временные ограничения');
                    } else if (openAlexResponse.status === 429) {
                        diagnostics.push('⚠️ Превышен лимит запросов (статус: 429) - подождите несколько минут');
                    } else {
                        diagnostics.push(`❌ OpenAlex API недоступен (статус: ${openAlexResponse.status})`);
                    }
                } catch (error) {
                    if (error.message.includes('Failed to fetch')) {
                        diagnostics.push('❌ Не удается подключиться к OpenAlex API (CORS или сетевые проблемы)');
                    } else {
                        diagnostics.push(`❌ Ошибка при подключении к OpenAlex API: ${error.message}`);
                    }
                }
                
                // Проверка 3: Простейший запрос к OpenAlex API
                try {
                    const simpleResponse = await fetch('https://api.openalex.org/works?search=test&per-page=1');
                    
                    if (simpleResponse.ok) {
                        diagnostics.push('✅ Простейший запрос к OpenAlex API работает');
                    } else {
                        diagnostics.push(`⚠️ Простейший запрос не работает (статус: ${simpleResponse.status})`);
                    }
                } catch (error) {
                    diagnostics.push(`❌ Простейший запрос тоже не работает: ${error.message}`);
                }
                
                // Проверка 4: Информация о браузере
                const userAgent = navigator.userAgent;
                const isChrome = userAgent.includes('Chrome');
                const isFirefox = userAgent.includes('Firefox');
                const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');
                const isEdge = userAgent.includes('Edge');
                
                let browserInfo = '';
                if (isChrome) browserInfo = 'Chrome';
                else if (isFirefox) browserInfo = 'Firefox';
                else if (isSafari) browserInfo = 'Safari';
                else if (isEdge) browserInfo = 'Edge';
                else browserInfo = 'Неизвестный браузер';
                
                diagnostics.push(`ℹ️ Браузер: ${browserInfo}`);
                diagnostics.push(`ℹ️ User Agent: ${userAgent.substring(0, 100)}...`);
                
                // Отображение результатов диагностики
                resultsList.innerHTML = `
                    <div class="error">
                        <h3>🔧 Результаты диагностики</h3>
                        <div style="text-align: left; margin: 20px 0;">
                            ${diagnostics.map(d => `<div style="margin: 10px 0;">${d}</div>`).join('')}
                        </div>
                        <div style="margin-top: 20px;">
                            <button class="search-btn" onclick="window.sciSearcher.retrySearch()" style="margin-right: 10px;">
                                🔄 Попробовать поиск снова
                            </button>
                            <button class="search-btn" onclick="window.sciSearcher.tryAlternativeSearch()" style="background: #28a745;">
                                🔍 Альтернативный поиск
                            </button>
                        </div>
                    </div>
                `;
            }

            // Функция для анализа языков в текущих результатах
            analyzeLanguages() {
                if (!this.currentResults || this.currentResults.length === 0) {
                    console.log('Нет результатов для анализа языков');
                    return;
                }
                
                console.log('=== АНАЛИЗ ЯЗЫКОВ В ТЕКУЩИХ РЕЗУЛЬТАТАХ ===');
                
                const allLanguages = new Set();
                const languageStats = {};
                
                this.currentResults.forEach(work => {
                    const lang = work.language || 'не указан';
                    allLanguages.add(lang);
                    languageStats[lang] = (languageStats[lang] || 0) + 1;
                });
                
                console.log('Все языки в текущих результатах:', Array.from(allLanguages));
                console.log('Статистика языков:', languageStats);
                
                // Показываем примеры для каждого языка
                Object.keys(languageStats).forEach(lang => {
                    const examples = this.currentResults.filter(work => (work.language || 'не указан') === lang).slice(0, 3);
                    console.log(`Примеры для языка "${lang}":`, examples.map(w => w.title?.substring(0, 50) + '...'));
                });
                
                console.log('=== КОНЕЦ АНАЛИЗА ===');
            }

            // Функция для тестирования всех комбинаций фильтров
            async testAllFilterCombinations() {
                const testKeywords = 'machine learning';
                const testCombinations = [
                    // Базовые тесты
                    { startYear: 2020, endYear: 2023, language: 'en', openAccess: 'open', filterType: 'journals', sortOrder: 'newest' },
                    { startYear: 2020, endYear: 2023, language: 'ru', openAccess: 'all', filterType: 'all', sortOrder: 'relevance' },
                    { startYear: 2020, endYear: 2023, language: 'all', openAccess: 'closed', filterType: 'conferences', sortOrder: 'oldest' },
                    
                    // Тесты только по годам
                    { startYear: 2020, endYear: 2023, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    { startYear: 2020, endYear: null, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    { startYear: null, endYear: 2023, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    
                    // Тесты только по языку
                    { startYear: null, endYear: null, language: 'en', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'ru', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'kk', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    
                    // Тесты только по типу публикаций
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'journals', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'conferences', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'books', sortOrder: 'newest' },
                    
                    // Тесты только по открытому доступу
                    { startYear: null, endYear: null, language: 'all', openAccess: 'open', filterType: 'all', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'all', openAccess: 'closed', filterType: 'all', sortOrder: 'newest' },
                    
                    // Тесты только по сортировке
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'newest' },
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'oldest' },
                    { startYear: null, endYear: null, language: 'all', openAccess: 'all', filterType: 'all', sortOrder: 'relevance' },
                ];
                
                console.log('🧪 Начинаем тестирование всех комбинаций фильтров...');
                const results = [];
                
                for (let i = 0; i < testCombinations.length; i++) {
                    const combo = testCombinations[i];
                    console.log(`\n--- Тест ${i + 1}/${testCombinations.length} ---`);
                    console.log('Параметры:', combo);
                    
                    try {
                        const startTime = Date.now();
                        const searchResults = await this.searchOpenAlex(
                            testKeywords, 
                            combo.startYear, 
                            combo.endYear, 
                            25, 
                            combo.sortOrder, 
                            combo.filterType, 
                            combo.language, 
                            combo.openAccess
                        );
                        const endTime = Date.now();
                        
                        const testResult = {
                            combination: combo,
                            success: true,
                            resultsCount: searchResults.length,
                            duration: endTime - startTime,
                            error: null
                        };
                        
                        results.push(testResult);
                        console.log(`✅ Успешно: ${searchResults.length} результатов за ${endTime - startTime}мс`);
                        
                        // Небольшая задержка между тестами
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                    } catch (error) {
                        const testResult = {
                            combination: combo,
                            success: false,
                            resultsCount: 0,
                            duration: 0,
                            error: error.message
                        };
                        
                        results.push(testResult);
                        console.log(`❌ Ошибка: ${error.message}`);
                    }
                }
                
                // Выводим сводку результатов
                console.log('\n📊 СВОДКА ТЕСТИРОВАНИЯ:');
                console.log(`Всего тестов: ${results.length}`);
                console.log(`Успешных: ${results.filter(r => r.success).length}`);
                console.log(`Неудачных: ${results.filter(r => !r.success).length}`);
                
                const successfulTests = results.filter(r => r.success);
                if (successfulTests.length > 0) {
                    const avgResults = successfulTests.reduce((sum, r) => sum + r.resultsCount, 0) / successfulTests.length;
                    const avgDuration = successfulTests.reduce((sum, r) => sum + r.duration, 0) / successfulTests.length;
                    console.log(`Среднее количество результатов: ${avgResults.toFixed(1)}`);
                    console.log(`Среднее время выполнения: ${avgDuration.toFixed(0)}мс`);
                }
                
                // Показываем неудачные тесты
                const failedTests = results.filter(r => !r.success);
                if (failedTests.length > 0) {
                    console.log('\n❌ НЕУДАЧНЫЕ ТЕСТЫ:');
                    failedTests.forEach((test, index) => {
                        console.log(`${index + 1}. ${JSON.stringify(test.combination)} - ${test.error}`);
                    });
                }
                
                return results;
            }

            // Методы кэширования
            getCacheKey(keywords, startYear, endYear, resultsLimit, sortOrder, filterType, language, openAccess) {
                return `${keywords}_${startYear}_${endYear}_${resultsLimit}_${sortOrder}_${filterType}_${language}_${openAccess}`;
            }

            getFromCache(key) {
                const cached = this.cache.get(key);
                if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
                    console.log('Используем кэшированные результаты');
                    return cached.data;
                }
                return null;
            }

            setCache(key, data) {
                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });
                console.log('Результаты сохранены в кэш');
            }

        }

        // Функции управления настройками
        function loadSettings() {
            // Загружаем настройки поиска
            const savedSettings = localStorage.getItem('searchSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    if (settings.sortOrder) document.getElementById('sortOrder').value = settings.sortOrder;
                    if (settings.filterType) document.getElementById('filterType').value = settings.filterType;
                    if (settings.language) document.getElementById('language').value = settings.language;
                    if (settings.openAccess) document.getElementById('openAccess').value = settings.openAccess;
                    if (settings.resultsLimit) document.getElementById('resultsLimit').value = settings.resultsLimit;
                } catch (e) {
                    console.warn('Ошибка загрузки настроек:', e);
                }
            }
        }

        function saveSettings() {
            const settings = {
                sortOrder: document.getElementById('sortOrder').value,
                filterType: document.getElementById('filterType').value,
                language: document.getElementById('language').value,
                openAccess: document.getElementById('openAccess').value,
                resultsLimit: document.getElementById('resultsLimit').value
            };
            localStorage.setItem('searchSettings', JSON.stringify(settings));
        }

        // Горячие клавиши
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter - поиск
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                const searchBtn = document.getElementById('openalexSearchBtn');
                if (searchBtn) searchBtn.click();
            }
            
            // Escape - очистка результатов
            if (e.key === 'Escape') {
                const resultsPanel = document.getElementById('resultsPanel');
                if (resultsPanel && resultsPanel.style.display !== 'none') {
                    resultsPanel.style.display = 'none';
                }
            }
        });

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', () => {
            console.log('📄 DOM загружен, начинаем инициализацию...');
            
            // Проверка FilterEngine
            if (typeof FilterEngine !== 'undefined') {
                console.log('✅ FilterEngine загружен и доступен');
            } else {
                console.error('❌ FilterEngine не определен! Это критическая ошибка!');
            }
            
            // Устанавливаем значения по умолчанию для последних 6 лет
            const currentYear = new Date().getFullYear();
            const startYearDefault = currentYear - 5; // Последние 6 лет (включая текущий)
            
            const startYearInput = document.getElementById('startYear');
            const endYearInput = document.getElementById('endYear');
            
            if (startYearInput) {
                startYearInput.placeholder = startYearDefault.toString();
                // Устанавливаем значение по умолчанию, если поле пустое
                if (!startYearInput.value) {
                    startYearInput.value = startYearDefault;
                }
                console.log('✅ Поле startYear инициализировано');
            } else {
                console.warn('⚠️ Поле startYear не найдено');
            }
            
            if (endYearInput) {
                endYearInput.placeholder = currentYear.toString();
                // Устанавливаем значение по умолчанию, если поле пустое
                if (!endYearInput.value) {
                    endYearInput.value = currentYear;
                }
                console.log('✅ Поле endYear инициализировано');
            } else {
                console.warn('⚠️ Поле endYear не найдено');
            }
            
            // Обновляем отображение текущего года в подсказке
            const currentYearDisplay = document.getElementById('currentYearDisplay');
            if (currentYearDisplay) {
                currentYearDisplay.textContent = currentYear.toString();
            }
            
            // Проверяем наличие формы перед инициализацией
            const form = document.getElementById('openalexForm');
            if (!form) {
                console.error('❌ Форма openalexForm не найдена в DOM!');
            } else {
                console.log('✅ Форма openalexForm найдена в DOM');
            }
            
            loadSettings();
            
            try {
            window.sciSearcher = new SciSearcher();
                console.log('✅ Экземпляр SciSearcher создан:', window.sciSearcher);
            } catch (error) {
                console.error('❌ Ошибка при создании SciSearcher:', error);
            }
            
            // Сохраняем настройки при изменении
            ['sortOrder', 'filterType', 'language', 'openAccess', 'resultsLimit'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', saveSettings);
                } else {
                    console.warn(`⚠️ Элемент ${id} не найден`);
                }
            });
            
            console.log('✅ Инициализация завершена');
        });
    </script>
</body>
</html>
